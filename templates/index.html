<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CSV Data D3.js Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    <h1>Visualización de Datos con D3.js</h1>
    <div class="visualization-container">
        <div class="chart">
            <div class="chart-title">
                RadViz Visualization
                <span class="info-icon">i
                    <span class="info-tooltip">
                        Visualización RadViz: Esta visualización representa cada dato como un punto en el espacio. Las características (features) se distribuyen alrededor del círculo como "anclajes". Puedes arrastrar estos anclajes para reorganizarlos y ver cómo cambia la distribución de los datos, revelando diferentes relaciones entre las variables.
                    </span>
                </span>
            </div>
            <div id="radviz"></div>
        </div>
        <div class="chart">
            <div class="chart-title">
                Parallel Coordinates
                <span class="info-icon">i
                    <span class="info-tooltip">
                        Coordenadas Paralelas: Cada línea vertical representa una característica y cada línea horizontal conectada representa un dato. Puedes arrastrar las columnas para reordenarlas y descubrir correlaciones. También puedes seleccionar rangos en cualquier eje para filtrar los datos y explorar subconjuntos específicos.
                    </span>
                </span>
            </div>
            <div id="parallel"></div>
        </div>
    </div>
    
    <script>
        // Data and config from Flask
        const data = JSON.parse('{{ data|safe }}');
        const dimensions = JSON.parse('{{ dimensions|safe }}');
        const label_col = "{{ label_col }}";
        const raw_data = JSON.parse('{{ raw_data|safe }}');
        
        // Color scale
        const classes = Array.from(new Set(data.map(d => d[label_col])));
        const color = d3.scaleOrdinal()
          .domain(classes)
          .range(d3.schemeCategory10);
        
        // Tooltip div
        const tooltip = d3.select("body").append("div")
          .style("position", "absolute")
          .style("pointer-events", "none")
          .style("background", "rgba(255,255,255,0.95)")
          .style("border", "1px solid #ccc")
          .style("padding", "4px 8px")
          .style("border-radius", "4px")
          .style("font", "12px sans-serif")
          .style("display", "none");
          
        //////////////////////////////////
        // RADVIZ VISUALIZATION
        //////////////////////////////////
        
        const width = 600, height = 400, margin = 40;
        const radius = Math.min(width, height) / 2 - margin;
        const D = dimensions.length;
        const anchors = dimensions.map((dim, j) => ({
          dim,
          x: radius * Math.cos((j * 2 * Math.PI) / D),
          y: radius * Math.sin((j * 2 * Math.PI) / D)
        }));

        // Function to compute RadViz positions
        function computePositions() {
          return data.map(d => {
            const values = dimensions.map(dim => +d[dim]);
            const sum = values.reduce((a, b) => a + b, 0) || 1;
            let x = 0, y = 0;
            dimensions.forEach((dim, j) => {
              const weight = values[j] / sum;
              x += weight * anchors[j].x;
              y += weight * anchors[j].y;
            });
            return {...d, x, y, label: d[label_col]};
          });
        }

        // Initial point positions
        let points = computePositions();

        // Draw SVG
        const svg = d3.select("#radviz")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        const g = svg.append("g")
          .attr("transform", `translate(${width/2},${height/2})`);

        // Panel circle
        g.append("circle")
          .attr("r", radius)
          .attr("fill", "#f8f8f8")
          .attr("stroke", "#ccc");

        // Drag behavior
        const drag = d3.drag()
          .on("start", dragStarted)
          .on("drag", dragged)
          .on("end", dragEnded);

        function dragStarted(event, d) {
          d3.select(this).raise().attr("fill", "orange");
        }

        function dragged(event, d) {
          // Calculate distance from center to keep within circle
          const dist = Math.sqrt(event.x * event.x + event.y * event.y);
          if (dist > radius) {
            const scale = radius / dist;
            d.x = event.x * scale;
            d.y = event.y * scale;
          } else {
            d.x = event.x;
            d.y = event.y;
          }
          
          // Update anchor position
          d3.select(this)
            .attr("cx", d.x)
            .attr("cy", d.y);
          
          // Update label position
          d3.select(`text[data-dim="${d.dim}"]`)
            .attr("x", d.x)
            .attr("y", d.y - 10);
          
          // Recalculate and update all points
          points = computePositions();
          updatePoints();
        }

        function dragEnded(event, d) {
          d3.select(this).attr("fill", "#555");
        }

        // Anchors
        g.selectAll(".anchor")
          .data(anchors)
          .enter()
          .append("circle")
          .attr("class", "anchor")
          .attr("r", 6)
          .attr("cx", d => d.x)
          .attr("cy", d => d.y)
          .attr("fill", "#555")
          .call(drag);

        g.selectAll(".anchor-label")
          .data(anchors)
          .enter()
          .append("text")
          .attr("class", "anchor-label")
          .attr("x", d => d.x)
          .attr("y", d => d.y - 10)
          .attr("text-anchor", "middle")
          .attr("data-dim", d => d.dim)
          .text(d => d.dim);

        // Dots container group
        const dotsGroup = g.append("g").attr("class", "dots-group");

        // Function to update points
        function updatePoints() {
          // Remove existing dots
          dotsGroup.selectAll(".dot").remove();
          
          // Add updated dots
          dotsGroup.selectAll(".dot")
            .data(points)
            .enter()
            .append("circle")
            .attr("class", "dot")
            .attr("r", 5)
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("fill", d => color(d.label))
            .attr("opacity", 0.6)
            .on("mouseover", (event, d) => {
              tooltip
                .style("display", "block")
                .html(`<strong>Class:</strong> ${d.label}`);
                
              // Highlight in parallel coordinates
              parallelHighlight(d);
            })
            .on("mousemove", event => {
              tooltip
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", () => {
              tooltip.style("display", "none");
              parallelUnhighlight();
            });
        }

        // Initial rendering of points
        updatePoints();
        
        //////////////////////////////////
        // PARALLEL COORDINATES PLOT
        //////////////////////////////////
        
        // Set dimensions and margins
        const pcWidth = 600;
        const pcHeight = 400;
        const pcMargin = {top: 30, right: 50, bottom: 30, left: 30};
        const pcInnerWidth = pcWidth - pcMargin.left - pcMargin.right;
        const pcInnerHeight = pcHeight - pcMargin.top - pcMargin.bottom;
        
        // Create SVG
        const pcSvg = d3.select("#parallel")
          .append("svg")
          .attr("width", pcWidth)
          .attr("height", pcHeight)
          .attr("class", "parallel-coordinates")
          .append("g")
          .attr("transform", `translate(${pcMargin.left},${pcMargin.top})`);
          
        // Initialize dimension positions array - store actual order of dimensions
        let dimensionPositions = [...dimensions];
        
        // Create scales for each dimension
        const y = {};
        for (let i = 0; i < dimensions.length; i++) {
            const name = dimensions[i];
            y[name] = d3.scaleLinear()
                .domain(d3.extent(raw_data, d => +d[name]))
                .range([pcInnerHeight, 0]);
        }
        
        // Build the x scale
        const x = d3.scalePoint()
            .domain(dimensionPositions)
            .range([0, pcInnerWidth]);
            
        // Path generator
        const line = d3.line()
            .defined(d => !isNaN(d[1]))
            .x(d => d[0])
            .y(d => d[1]);
            
        // Redraw function for parallel coordinates - called when dimensions are reordered
        function redrawParallelCoordinates() {
            // Update x scale domain with new order
            x.domain(dimensionPositions);
            
            // Update axes positions
            pcSvg.selectAll(".dimension")
                .transition()
                .duration(500)
                .attr("transform", d => `translate(${x(d)})`);
                
            // Update the paths
            pcSvg.selectAll(".foreground path")
                .transition()
                .duration(500)
                .attr("d", d => {
                    return line(dimensionPositions.map(dim => [x(dim), y[dim](+d[dim])]));
                });
        }
        
        // Draw the lines
        const foreground = pcSvg.append("g")
            .attr("class", "foreground")
            .selectAll("path")
            .data(raw_data)
            .enter()
            .append("path")
            .attr("d", d => {
                return line(dimensionPositions.map(dim => [x(dim), y[dim](+d[dim])]));
            })
            .attr("stroke", d => color(d[label_col]))
            .attr("data-id", (d, i) => i);
            
        // Drag behavior for dimensions
        const dimensionDrag = d3.drag()
            .on("start", function(event, d) {
                d3.select(this).raise().classed("dragging", true);
            })
            .on("drag", function(event, d) {
                // Get the current x position
                const currentX = event.x;
                
                // Find the closest position in the dimensions array
                const positions = dimensionPositions.map(dim => x(dim));
                let closestIndex = 0;
                let minDistance = Math.abs(positions[0] - currentX);
                
                for (let i = 1; i < positions.length; i++) {
                    const distance = Math.abs(positions[i] - currentX);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                // If the dimension is dragged to a different position, swap them
                const currentIndex = dimensionPositions.indexOf(d);
                if (currentIndex !== closestIndex) {
                    // Swap dimensions in the array
                    [dimensionPositions[currentIndex], dimensionPositions[closestIndex]] = 
                    [dimensionPositions[closestIndex], dimensionPositions[currentIndex]];
                    
                    // Redraw
                    redrawParallelCoordinates();
                }
            })
            .on("end", function(event, d) {
                d3.select(this).classed("dragging", false);
            });
            
        // Draw the axes
        const axes = pcSvg.selectAll(".dimension")
            .data(dimensionPositions)
            .enter()
            .append("g")
            .attr("class", "dimension")
            .attr("transform", d => `translate(${x(d)})`)
            .call(dimensionDrag);
            
        // Add axis title
        axes.append("text")
            .attr("class", "axis-title")
            .attr("y", -10)
            .attr("text-anchor", "middle")
            .text(d => d);
            
        // Add axis lines
        axes.append("g")
            .each(function(d) {
                d3.select(this).call(d3.axisLeft().scale(y[d]));
            });
            
        // Add brushes
        axes.append("g")
            .attr("class", "brush")
            .each(function(d) {
                d3.select(this).call(
                    d3.brushY()
                        .extent([[-8, 0], [8, pcInnerHeight]])
                        .on("start", brushstart)
                        .on("brush", brushed)
                        .on("end", brushend)
                );
            });
            
        function brushstart(event) {
            if (event.sourceEvent) event.sourceEvent.stopPropagation();
        }
            
        // Function to highlight a specific path in parallel coordinates
        function parallelHighlight(d) {
            foreground.style("opacity", 0.1);
            foreground.filter(p => p[label_col] === d[label_col])
                .style("opacity", 1)
                .style("stroke-width", "2px");
        }
        
        // Function to restore all paths
        function parallelUnhighlight() {
            foreground.style("opacity", 0.6)
                .style("stroke-width", "1.5px");
        }
        
        let actives = [];
        
        // Update data based on brush selection
        function brushed(event) {
            actives = [];
            
            pcSvg.selectAll(".brush")
                .filter(function() {
                    return d3.brushSelection(this);
                })
                .each(function(d) {
                    actives.push({
                        dimension: d,
                        extent: d3.brushSelection(this).map(y[d].invert)
                    });
                });
                
            if (actives.length === 0) {
                foreground.style("display", null);
            } else {
                foreground.style("display", d => {
                    return actives.every(active => {
                        const dim = active.dimension;
                        const value = +d[dim];
                        return active.extent[1] <= value && value <= active.extent[0];
                    }) ? null : "none";
                });
            }
        }
        
        function brushend(event) {
            if (!event.selection) {
                // If no selection, reset the brush
                actives = [];
                foreground.style("display", null);
            }
        }
    </script>
</body>
</html> 